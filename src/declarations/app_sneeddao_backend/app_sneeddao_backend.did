type WhitelistedToken = 
 record {
   decimals: nat8;
   fee: nat;
   ledger_id: principal;
   name: text;
   standard: text;
   symbol: text;
 };
type WalletLayout = 
 record {
   apps: vec principal;
   positions: vec principal;
   staking_bots: vec principal;
   tokens: vec principal;
 };
type UserSettingsUpdate = 
 record {
   always_show_remove_token: opt bool;
   canister_manager_cycle_threshold_orange: opt nat;
   canister_manager_cycle_threshold_red: opt nat;
   collectibles_threshold: opt float64;
   expand_quick_links_on_desktop: opt bool;
   frontend_auto_update_enabled: opt bool;
   frontend_clear_cache_on_update: opt bool;
   frontend_update_check_interval_sec: opt nat;
   frontend_update_countdown_sec: opt nat;
   neuron_color_coding: opt bool;
   neuron_manager_cycle_threshold_orange: opt nat;
   neuron_manager_cycle_threshold_red: opt nat;
   notify_bot_chores: opt bool;
   notify_collectibles: opt bool;
   notify_low_cycles: opt bool;
   notify_messages: opt bool;
   notify_outdated_bots: opt bool;
   notify_replies: opt bool;
   notify_tips: opt bool;
   notify_updates: opt bool;
   notify_votable_proposals: opt bool;
   particle_effects_enabled: opt bool;
   principal_color_coding: opt bool;
   show_header_notifications: opt bool;
   show_vp_bar: opt bool;
   swap_slippage_tolerance: opt float64;
 };
type UserSettings = 
 record {
   always_show_remove_token: bool;
   canister_manager_cycle_threshold_orange: nat;
   canister_manager_cycle_threshold_red: nat;
   collectibles_threshold: float64;
   expand_quick_links_on_desktop: bool;
   frontend_auto_update_enabled: bool;
   frontend_clear_cache_on_update: bool;
   frontend_update_check_interval_sec: nat;
   frontend_update_countdown_sec: nat;
   neuron_color_coding: bool;
   neuron_manager_cycle_threshold_orange: nat;
   neuron_manager_cycle_threshold_red: nat;
   notify_bot_chores: bool;
   notify_collectibles: bool;
   notify_low_cycles: bool;
   notify_messages: bool;
   notify_outdated_bots: bool;
   notify_replies: bool;
   notify_tips: bool;
   notify_updates: bool;
   notify_votable_proposals: bool;
   particle_effects_enabled: bool;
   principal_color_coding: bool;
   show_header_notifications: bool;
   show_vp_bar: bool;
   swap_slippage_tolerance: float64;
 };
type TxIndex = nat;
type TransferResult = 
 variant {
   Err: TransferError;
   Ok: TxIndex;
 };
type TransferPositionResult = 
 variant {
   err: TransferPositionError;
   ok: bool;
 };
type TransferPositionError = 
 variant {
   CommonError;
   InsufficientFunds;
   InternalError: text;
   UnsupportedToken: text;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: Balance;};
   BadFee: record {expected_fee: Balance;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: TxIndex;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: Balance;};
   TemporarilyUnavailable;
   TooOld;
 };
type TokenMetaValue = 
 variant {
   Blob: blob;
   Int: int;
   Nat: nat;
   Text: text;
 };
type TokenMeta = 
 record {
   token0: vec record {
                 text;
                 TokenMetaValue;
               };
   token1: vec record {
                 text;
                 TokenMetaValue;
               };
 };
type Timestamp = nat64;
type Result_9 = 
 variant {
   err: text;
   ok: record {
         controllers: vec principal;
         module_hash: opt blob;
       };
 };
type Result_8 = 
 variant {
   err: text;
   ok: record {
         logs: vec JailbreakPaymentLog;
         total: nat;
       };
 };
type Result_7 = 
 variant {
   err: text;
   ok:
    record {
      premium_revenue_e8s: nat;
      regular_revenue_e8s: nat;
      total_premium_payments: nat;
      total_regular_payments: nat;
      total_revenue_e8s: nat;
      total_scripts_created: nat;
      unique_users: nat;
    };
 };
type Result_6 = 
 variant {
   err: text;
   ok: vec BanLogEntry;
 };
type Result_5 = 
 variant {
   err: text;
   ok: vec Neuron;
 };
type Result_4 = 
 variant {
   err: text;
   ok: WhitelistedToken;
 };
type Result_3 = 
 variant {
   err: text;
   ok: UserSettings;
 };
type Result_2 = 
 variant {
   err: text;
   ok;
 };
type Result_10 = 
 variant {
   err: text;
   ok: vec record {
             principal;
             int;
           };
 };
type Result_1 = 
 variant {
   err: text;
   ok: text;
 };
type Result = 
 variant {
   err: text;
   ok: nat;
 };
type RefreshAllProgress = 
 record {
   current_token: text;
   errors: vec text;
   failed: nat;
   is_running: bool;
   processed: nat;
   success: nat;
   total: nat;
 };
type ProjectType = 
 variant {
   fork;
   product;
   project;
 };
type ProjectLink = 
 record {
   title: text;
   url: text;
 };
type Project = 
 record {
   created_at: int;
   description: text;
   id: nat;
   index: opt nat;
   links: vec ProjectLink;
   logo_url: opt text;
   name: text;
   project_type: ProjectType;
   updated_at: int;
 };
type PartnerLink = 
 record {
   title: text;
   url: text;
 };
type Partner = 
 record {
   created_at: int;
   description: text;
   id: nat;
   index: opt nat;
   links: vec PartnerLink;
   logo_url: text;
   name: text;
   updated_at: int;
 };
type NeuronNameKey = 
 record {
   neuron_id: NeuronId;
   sns_root_canister_id: principal;
 };
type NeuronId = record {id: blob;};
type Neuron = 
 record {
   id: opt NeuronId;
   permissions: vec record {
                      principal;
                      vec int32;
                    };
 };
type JailbreakPaymentLog = 
 record {
   amount_e8s: nat;
   config_id: nat;
   id: nat;
   is_premium: bool;
   neuron_id_hex: text;
   sns_root_canister_id: principal;
   target_principal: principal;
   timestamp: int;
   user: principal;
 };
type JailbreakConfig = 
 record {
   created_at: int;
   id: nat;
   neuron_id_hex: text;
   sns_root_canister_id: principal;
   target_principal: principal;
 };
type CanisterGroupsRoot = 
 record {
   groups: vec CanisterGroup;
   ungrouped: vec principal;
 };
type CanisterGroup = 
 record {
   canisters: vec principal;
   id: text;
   name: text;
   subgroups: vec CanisterGroup;
 };
type BanLogEntry = 
 record {
   admin: principal;
   ban_timestamp: int;
   expiry_timestamp: int;
   reason: text;
   user: principal;
 };
type Balance = nat;
type AppSneedDaoBackend = 
 service {
   add_admin: ("principal": principal) -> ();
   add_authorized_for_caller: (canister_id: principal) -> ();
   add_blacklisted_word: (word: text) -> (Result_2);
   add_partner: (name: text, logo_url: text, description: text, links:
    vec PartnerLink, index: opt nat) -> (Result);
   add_project: (name: text, logo_url: opt text, description: text,
    project_type: ProjectType, links: vec ProjectLink, index: opt nat) ->
    (Result);
   add_whitelisted_token: (token: WhitelistedToken) -> ();
   ban_user: (user: principal, duration_hours: nat, reason: text) ->
    (Result_2);
   caller_is_admin: () -> (bool) query;
   check_ban_status: (user: principal) -> (Result_2) query;
   delete_canister_groups: () -> ();
   delete_jailbreak_config: (id: nat) -> (Result_2);
   get_admins: () -> (vec principal) query;
   get_all_jailbreak_configs_count: () -> (Result) query;
   get_all_neuron_names: () ->
    (vec record {
           NeuronNameKey;
           record {
             text;
             bool;
           };
         }) query;
   get_all_neuron_nicknames: () -> (vec record {
                                          NeuronNameKey;
                                          text;
                                        }) query;
   get_all_principal_names: () ->
    (vec record {
           principal;
           record {
             text;
             bool;
           };
         }) query;
   get_all_principal_nicknames: () -> (vec record {
                                             principal;
                                             text;
                                           }) query;
   get_authorized_for_callers: () -> (vec principal) query;
   get_ban_log: () -> (Result_6) query;
   get_banned_users: () -> (Result_10) query;
   get_blacklisted_words: () -> (vec text) query;
   get_cached_token_meta: (swap_canister_id: principal) ->
    (opt TokenMeta) query;
   get_canister_groups: () -> (opt CanisterGroupsRoot) query;
   get_canister_groups_limits_config: () ->
    (record {
       max_canister_groups: nat;
       max_canisters_per_group: nat;
       max_total_grouped_canisters: nat;
       premium_max_canister_groups: nat;
       premium_max_canisters_per_group: nat;
       premium_max_total_grouped_canisters: nat;
     }) query;
   get_canister_info: (canister_id: principal) -> (Result_9);
   get_jailbreak_fee_settings: () ->
    (record {
       fee_account_owner: opt principal;
       fee_account_subaccount: opt blob;
       fee_premium_e8s: nat;
       fee_regular_e8s: nat;
     }) query;
   get_jailbreak_payment_balance: () -> (nat);
   get_jailbreak_payment_logs: (offset: nat, limit: nat) -> (Result_8) query;
   get_jailbreak_payment_stats: () -> (Result_7) query;
   get_jailbreak_payment_subaccount: () -> (blob) query;
   get_ledger_canister_ids: () -> (vec principal) query;
   get_my_canister_groups_usage: () ->
    (record {
       group_count: nat;
       group_limit: nat;
       is_premium: bool;
       max_in_single_group: nat;
       per_group_limit: nat;
       total_canisters: nat;
       total_limit: nat;
       ungrouped_count: nat;
     });
   get_my_jailbreak_configs: () -> (vec JailbreakConfig) query;
   get_my_jailbreak_fee: () -> (nat);
   get_my_nickname_usage: () ->
    (record {
       is_premium: bool;
       neuron_nickname_count: nat;
       neuron_nickname_limit: nat;
       principal_nickname_count: nat;
       principal_nickname_limit: nat;
     });
   get_my_settings: () -> (UserSettings) query;
   get_neuron_name: (sns_root_canister_id: principal, neuron_id: NeuronId) ->
    (opt record {
           text;
           bool;
         }) query;
   get_neuron_nickname: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (opt text) query;
   get_nickname_limits_config: () ->
    (record {
       max_neuron_nicknames: nat;
       max_principal_nicknames: nat;
       premium_max_neuron_nicknames: nat;
       premium_max_principal_nicknames: nat;
       sneed_premium_canister_id: opt principal;
     }) query;
   get_partner: (id: nat) -> (opt Partner) query;
   get_partners: () -> (vec Partner) query;
   get_principal_name: ("principal": principal) ->
    (opt record {
           text;
           bool;
         }) query;
   get_principal_nickname: ("principal": principal) -> (opt text) query;
   get_project: (id: nat) -> (opt Project) query;
   get_projects: () -> (vec Project) query;
   get_refresh_all_progress: () -> (RefreshAllProgress) query;
   get_swap_canister_ids: () -> (vec principal) query;
   get_tracked_canisters: () -> (vec principal) query;
   get_user_ban_history: (user: principal) -> (Result_6) query;
   get_user_neurons: () -> (Result_5);
   get_user_tokens: () -> (vec principal) query;
   get_wallet_layout: () -> (opt WalletLayout) query;
   get_whitelisted_tokens: () -> (vec WhitelistedToken) query;
   import_whitelist_from_swaprunner: () -> ();
   is_token_whitelisted: (ledger_id: principal) -> (bool) query;
   refresh_token_metadata: (ledger_id: principal) -> (Result_4);
   register_ledger_canister_id: (icrc1_ledger_canister_id: principal) -> ();
   register_swap_canister_id: (icrc1_swap_canister_id: principal) -> ();
   register_tracked_canister: (canister_id: principal) -> ();
   register_tracked_canister_for: (user: principal, canister_id:
    principal) -> ();
   register_user_token: (ledger_id: principal) -> ();
   register_user_token_for: (user: principal, ledger_id: principal) -> ();
   remove_admin: ("principal": principal) -> ();
   remove_authorized_for_caller: (canister_id: principal) -> ();
   remove_blacklisted_word: (word: text) -> (Result_2);
   remove_partner: (id: nat) -> (Result_2);
   remove_project: (id: nat) -> (Result_2);
   remove_whitelisted_token: (ledger_id: principal) -> ();
   save_jailbreak_config: (sns_root_canister_id: principal, neuron_id_hex:
    text, target_principal: principal) -> (Result);
   send_tokens: (icrc1_ledger_canister_id: principal, amount: nat, to:
    principal) -> (TransferResult);
   set_cached_token_meta: (swap_canister_id: principal, new_token_meta:
    TokenMeta) -> ();
   set_canister_groups: (groups: CanisterGroupsRoot) -> (Result_2);
   set_canister_name: (canister_id: principal, name: text) -> (Result_1);
   set_jailbreak_fee_settings: (fee_premium_e8s: opt nat, fee_regular_e8s:
    opt nat, fee_account_owner: opt opt principal, fee_account_subaccount:
    opt opt blob) -> (Result_2);
   set_my_settings: (update: UserSettingsUpdate) -> (Result_3);
   set_neuron_name: (sns_root_canister_id: principal, neuron_id: NeuronId,
    name: text) -> (Result_1);
   set_neuron_nickname: (sns_root_canister_id: principal, neuron_id:
    NeuronId, nickname: text) -> (Result_1);
   set_nickname_premium_canister: (canister_id: opt principal) -> (Result_2);
   set_principal_name: (name: text) -> (Result_1);
   set_principal_name_for: ("principal": principal, name: text,
    sns_root_canister_id: opt principal) -> (Result_1);
   set_principal_nickname: ("principal": principal, nickname: text) ->
    (Result_1);
   set_wallet_layout: (layout: WalletLayout) -> ();
   start_refresh_all_token_metadata: () -> (Result_2);
   stop_refresh_all_token_metadata: () -> ();
   test_calculate_ban_duration: (user: principal) -> (nat);
   transfer_position: (swap_canister_id: principal, to: principal,
    position_id: nat) -> (TransferPositionResult);
   unban_user: (user: principal) -> (Result_2);
   unregister_ledger_canister_id: (icrc1_ledger_canister_id: principal) -> ();
   unregister_swap_canister_id: (icrc1_swap_canister_id: principal) -> ();
   unregister_tracked_canister: (canister_id: principal) -> ();
   unregister_tracked_canister_for: (user: principal, canister_id:
    principal) -> ();
   unregister_user_token: (ledger_id: principal) -> ();
   unregister_user_token_for: (user: principal, ledger_id: principal) -> ();
   unverify_neuron_name: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (Result_1);
   unverify_principal_name: ("principal": principal) -> (Result_1);
   update_canister_groups_limits: (max_groups: opt nat, max_per_group:
    opt nat, max_total: opt nat, premium_max_groups: opt nat,
    premium_max_per_group: opt nat, premium_max_total: opt nat) -> (Result_2);
   update_nickname_limits: (max_neuron_nicknames: opt nat,
    max_principal_nicknames: opt nat, premium_max_neuron_nicknames: opt nat,
    premium_max_principal_nicknames: opt nat) -> (Result_2);
   update_partner: (id: nat, name: text, logo_url: text, description: 
    text, links: vec PartnerLink, index: opt nat) -> (Result_2);
   update_project: (id: nat, name: text, logo_url: opt text, description:
    text, project_type: ProjectType, links: vec ProjectLink, index:
    opt nat) -> (Result_2);
   verify_neuron_name: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (Result_1);
   verify_principal_name: ("principal": principal) -> (Result_1);
   withdraw_jailbreak_payment: (amount: nat) -> (Result);
 };
service : () -> AppSneedDaoBackend
