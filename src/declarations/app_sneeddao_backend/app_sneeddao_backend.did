type WhitelistedToken = 
 record {
   decimals: nat8;
   fee: nat;
   ledger_id: principal;
   name: text;
   standard: text;
   symbol: text;
 };
type TxIndex = nat;
type TransferResult = 
 variant {
   Err: TransferError;
   Ok: TxIndex;
 };
type TransferPositionResult = 
 variant {
   err: TransferPositionError;
   ok: bool;
 };
type TransferPositionError = 
 variant {
   CommonError;
   InsufficientFunds;
   InternalError: text;
   UnsupportedToken: text;
 };
type TransferError = 
 variant {
   BadBurn: record {min_burn_amount: Balance;};
   BadFee: record {expected_fee: Balance;};
   CreatedInFuture: record {ledger_time: Timestamp;};
   Duplicate: record {duplicate_of: TxIndex;};
   GenericError: record {
                   error_code: nat;
                   message: text;
                 };
   InsufficientFunds: record {balance: Balance;};
   TemporarilyUnavailable;
   TooOld;
 };
type TokenMetaValue = 
 variant {
   Blob: blob;
   Int: int;
   Nat: nat;
   Text: text;
 };
type TokenMeta = 
 record {
   token0: vec record {
                 text;
                 TokenMetaValue;
               };
   token1: vec record {
                 text;
                 TokenMetaValue;
               };
 };
type Timestamp = nat64;
type Result_6 = 
 variant {
   err: text;
   ok: vec record {
             principal;
             int;
           };
 };
type Result_5 = 
 variant {
   err: text;
   ok: record {
         controllers: vec principal;
         module_hash: opt blob;
       };
 };
type Result_4 = 
 variant {
   err: text;
   ok: vec BanLogEntry;
 };
type Result_3 = 
 variant {
   err: text;
   ok: vec Neuron;
 };
type Result_2 = 
 variant {
   err: text;
   ok: nat;
 };
type Result_1 = 
 variant {
   err: text;
   ok;
 };
type Result = 
 variant {
   err: text;
   ok: text;
 };
type ProjectType = 
 variant {
   fork;
   product;
   project;
 };
type ProjectLink = 
 record {
   title: text;
   url: text;
 };
type Project = 
 record {
   created_at: int;
   description: text;
   id: nat;
   index: opt nat;
   links: vec ProjectLink;
   logo_url: opt text;
   name: text;
   project_type: ProjectType;
   updated_at: int;
 };
type PartnerLink = 
 record {
   title: text;
   url: text;
 };
type Partner = 
 record {
   created_at: int;
   description: text;
   id: nat;
   index: opt nat;
   links: vec PartnerLink;
   logo_url: text;
   name: text;
   updated_at: int;
 };
type NeuronNameKey = 
 record {
   neuron_id: NeuronId;
   sns_root_canister_id: principal;
 };
type NeuronId = record {id: blob;};
type Neuron = 
 record {
   id: opt NeuronId;
   permissions: vec record {
                      principal;
                      vec int32;
                    };
 };
type JailbreakConfig = 
 record {
   created_at: int;
   id: nat;
   neuron_id_hex: text;
   sns_root_canister_id: principal;
   target_principal: principal;
 };
type CanisterGroupsRoot = 
 record {
   groups: vec CanisterGroup;
   ungrouped: vec principal;
 };
type CanisterGroup = 
 record {
   canisters: vec principal;
   id: text;
   name: text;
   subgroups: vec CanisterGroup;
 };
type BanLogEntry = 
 record {
   admin: principal;
   ban_timestamp: int;
   expiry_timestamp: int;
   reason: text;
   user: principal;
 };
type Balance = nat;
type AppSneedDaoBackend = 
 service {
   add_admin: ("principal": principal) -> ();
   add_authorized_for_caller: (canister_id: principal) -> ();
   add_blacklisted_word: (word: text) -> (Result_1);
   add_partner: (name: text, logo_url: text, description: text, links:
    vec PartnerLink, index: opt nat) -> (Result_2);
   add_project: (name: text, logo_url: opt text, description: text,
    project_type: ProjectType, links: vec ProjectLink, index: opt nat) ->
    (Result_2);
   add_whitelisted_token: (token: WhitelistedToken) -> ();
   ban_user: (user: principal, duration_hours: nat, reason: text) ->
    (Result_1);
   caller_is_admin: () -> (bool) query;
   check_ban_status: (user: principal) -> (Result_1) query;
   delete_canister_groups: () -> ();
   delete_jailbreak_config: (id: nat) -> (Result_1);
   get_admins: () -> (vec principal) query;
   get_all_neuron_names: () ->
    (vec record {
           NeuronNameKey;
           record {
             text;
             bool;
           };
         }) query;
   get_all_neuron_nicknames: () -> (vec record {
                                          NeuronNameKey;
                                          text;
                                        }) query;
   get_all_principal_names: () ->
    (vec record {
           principal;
           record {
             text;
             bool;
           };
         }) query;
   get_all_principal_nicknames: () -> (vec record {
                                             principal;
                                             text;
                                           }) query;
   get_authorized_for_callers: () -> (vec principal) query;
   get_ban_log: () -> (Result_4) query;
   get_banned_users: () -> (Result_6) query;
   get_blacklisted_words: () -> (vec text) query;
   get_cached_token_meta: (swap_canister_id: principal) ->
    (opt TokenMeta) query;
   get_canister_groups: () -> (opt CanisterGroupsRoot) query;
   get_canister_groups_limits_config: () ->
    (record {
       max_canister_groups: nat;
       max_canisters_per_group: nat;
       max_total_grouped_canisters: nat;
       premium_max_canister_groups: nat;
       premium_max_canisters_per_group: nat;
       premium_max_total_grouped_canisters: nat;
     }) query;
   get_canister_info: (canister_id: principal) -> (Result_5);
   get_ledger_canister_ids: () -> (vec principal) query;
   get_my_canister_groups_usage: () ->
    (record {
       group_count: nat;
       group_limit: nat;
       is_premium: bool;
       max_in_single_group: nat;
       per_group_limit: nat;
       total_canisters: nat;
       total_limit: nat;
       ungrouped_count: nat;
     });
   get_my_jailbreak_configs: () -> (vec JailbreakConfig) query;
   get_my_nickname_usage: () ->
    (record {
       is_premium: bool;
       neuron_nickname_count: nat;
       neuron_nickname_limit: nat;
       principal_nickname_count: nat;
       principal_nickname_limit: nat;
     });
   get_neuron_name: (sns_root_canister_id: principal, neuron_id: NeuronId) ->
    (opt record {
           text;
           bool;
         }) query;
   get_neuron_nickname: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (opt text) query;
   get_nickname_limits_config: () ->
    (record {
       max_neuron_nicknames: nat;
       max_principal_nicknames: nat;
       premium_max_neuron_nicknames: nat;
       premium_max_principal_nicknames: nat;
       sneed_premium_canister_id: opt principal;
     }) query;
   get_partner: (id: nat) -> (opt Partner) query;
   get_partners: () -> (vec Partner) query;
   get_principal_name: ("principal": principal) ->
    (opt record {
           text;
           bool;
         }) query;
   get_principal_nickname: ("principal": principal) -> (opt text) query;
   get_project: (id: nat) -> (opt Project) query;
   get_projects: () -> (vec Project) query;
   get_swap_canister_ids: () -> (vec principal) query;
   get_tracked_canisters: () -> (vec principal) query;
   get_user_ban_history: (user: principal) -> (Result_4) query;
   get_user_neurons: () -> (Result_3);
   get_user_tokens: () -> (vec principal) query;
   get_whitelisted_tokens: () -> (vec WhitelistedToken) query;
   import_whitelist_from_swaprunner: () -> ();
   is_token_whitelisted: (ledger_id: principal) -> (bool) query;
   register_ledger_canister_id: (icrc1_ledger_canister_id: principal) -> ();
   register_swap_canister_id: (icrc1_swap_canister_id: principal) -> ();
   register_tracked_canister: (canister_id: principal) -> ();
   register_tracked_canister_for: (user: principal, canister_id:
    principal) -> ();
   register_user_token: (ledger_id: principal) -> ();
   register_user_token_for: (user: principal, ledger_id: principal) -> ();
   remove_admin: ("principal": principal) -> ();
   remove_authorized_for_caller: (canister_id: principal) -> ();
   remove_blacklisted_word: (word: text) -> (Result_1);
   remove_partner: (id: nat) -> (Result_1);
   remove_project: (id: nat) -> (Result_1);
   remove_whitelisted_token: (ledger_id: principal) -> ();
   save_jailbreak_config: (sns_root_canister_id: principal, neuron_id_hex:
    text, target_principal: principal) -> (Result_2);
   send_tokens: (icrc1_ledger_canister_id: principal, amount: nat, to:
    principal) -> (TransferResult);
   set_cached_token_meta: (swap_canister_id: principal, new_token_meta:
    TokenMeta) -> ();
   set_canister_groups: (groups: CanisterGroupsRoot) -> (Result_1);
   set_canister_name: (canister_id: principal, name: text) -> (Result);
   set_neuron_name: (sns_root_canister_id: principal, neuron_id: NeuronId,
    name: text) -> (Result);
   set_neuron_nickname: (sns_root_canister_id: principal, neuron_id:
    NeuronId, nickname: text) -> (Result);
   set_nickname_premium_canister: (canister_id: opt principal) -> (Result_1);
   set_principal_name: (name: text) -> (Result);
   set_principal_name_for: ("principal": principal, name: text,
    sns_root_canister_id: opt principal) -> (Result);
   set_principal_nickname: ("principal": principal, nickname: text) ->
    (Result);
   test_calculate_ban_duration: (user: principal) -> (nat);
   transfer_position: (swap_canister_id: principal, to: principal,
    position_id: nat) -> (TransferPositionResult);
   unban_user: (user: principal) -> (Result_1);
   unregister_ledger_canister_id: (icrc1_ledger_canister_id: principal) -> ();
   unregister_swap_canister_id: (icrc1_swap_canister_id: principal) -> ();
   unregister_tracked_canister: (canister_id: principal) -> ();
   unregister_tracked_canister_for: (user: principal, canister_id:
    principal) -> ();
   unregister_user_token: (ledger_id: principal) -> ();
   unregister_user_token_for: (user: principal, ledger_id: principal) -> ();
   unverify_neuron_name: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (Result);
   unverify_principal_name: ("principal": principal) -> (Result);
   update_canister_groups_limits: (max_groups: opt nat, max_per_group:
    opt nat, max_total: opt nat, premium_max_groups: opt nat,
    premium_max_per_group: opt nat, premium_max_total: opt nat) -> (Result_1);
   update_nickname_limits: (max_neuron_nicknames: opt nat,
    max_principal_nicknames: opt nat, premium_max_neuron_nicknames: opt nat,
    premium_max_principal_nicknames: opt nat) -> (Result_1);
   update_partner: (id: nat, name: text, logo_url: text, description: 
    text, links: vec PartnerLink, index: opt nat) -> (Result_1);
   update_project: (id: nat, name: text, logo_url: opt text, description:
    text, project_type: ProjectType, links: vec ProjectLink, index:
    opt nat) -> (Result_1);
   verify_neuron_name: (sns_root_canister_id: principal, neuron_id:
    NeuronId) -> (Result);
   verify_principal_name: ("principal": principal) -> (Result);
 };
service : () -> AppSneedDaoBackend
