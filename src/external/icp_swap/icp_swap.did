type WithdrawToSubaccountArgs = 
 record {
   amount: nat;
   fee: nat;
   subaccount: blob;
   token: text;
 };
type WithdrawStatus = 
 variant {
   Completed;
   Created;
   CreditCompleted;
   Failed;
 };
type WithdrawQueueItem = 
 record {
   amount: nat;
   caller: principal;
   fee: nat;
   from: Account;
   memo: opt blob;
   to: Account;
   token: Token;
   txIndex: nat;
 };
type WithdrawInfo = 
 record {
   err: opt Error__1;
   status: WithdrawStatus;
   transfer: Transfer;
 };
type WithdrawArgs = 
 record {
   amount: nat;
   fee: nat;
   token: text;
 };
type UserWithdrawQueueInfo = 
 record {
   items: vec WithdrawQueueItem;
   token0TotalAmount: nat;
   token1TotalAmount: nat;
 };
type UserPositionInfoWithTokenAmount = 
 record {
   feeGrowthInside0LastX128: nat;
   feeGrowthInside1LastX128: nat;
   id: nat;
   liquidity: nat;
   tickLower: int;
   tickUpper: int;
   token0Amount: nat;
   token1Amount: nat;
   tokensOwed0: nat;
   tokensOwed1: nat;
 };
type UserPositionInfoWithId = 
 record {
   feeGrowthInside0LastX128: nat;
   feeGrowthInside1LastX128: nat;
   id: nat;
   liquidity: nat;
   tickLower: int;
   tickUpper: int;
   tokensOwed0: nat;
   tokensOwed1: nat;
 };
type UserPositionInfo = 
 record {
   feeGrowthInside0LastX128: nat;
   feeGrowthInside1LastX128: nat;
   liquidity: nat;
   tickLower: int;
   tickUpper: int;
   tokensOwed0: nat;
   tokensOwed1: nat;
 };
type TransferPositionStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type TransferPositionInfo = 
 record {
   err: opt Error__1;
   from: Account;
   positionId: nat;
   status: TransferPositionStatus;
   to: Account;
   token0Amount: nat;
   token1Amount: nat;
 };
type Transfer = 
 record {
   amount: nat;
   fee: nat;
   from: Account;
   index: nat;
   memo: opt blob;
   standard: text;
   to: Account;
   token: principal;
 };
type Transaction__1 = 
 record {
   action: Action;
   canisterId: principal;
   id: nat;
   owner: principal;
   timestamp: Time;
 };
type Transaction = 
 record {
   action: Action;
   canisterId: principal;
   id: nat;
   owner: principal;
   timestamp: Time;
 };
type Token__1 = 
 record {
   address: principal;
   standard: text;
 };
type Token = 
 record {
   address: text;
   standard: text;
 };
type Time = int;
type TickLiquidityInfo = 
 record {
   liquidityGross: nat;
   liquidityNet: int;
   price0: nat;
   price0Decimal: nat;
   price1: nat;
   price1Decimal: nat;
   tickIndex: int;
 };
type TickInfoWithId = 
 record {
   feeGrowthOutside0X128: nat;
   feeGrowthOutside1X128: nat;
   id: text;
   initialized: bool;
   liquidityGross: nat;
   liquidityNet: int;
   secondsOutside: nat;
   secondsPerLiquidityOutsideX128: nat;
   tickCumulativeOutside: int;
 };
type SwapStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type SwapRecordInfo = 
 record {
   currentLiquidity: nat;
   currentSqrtPriceX96: nat;
   currentTick: int;
   poolFee: nat;
   txInfo: Transaction__1;
 };
type SwapInfo = 
 record {
   amountIn: Amount;
   amountInFee: nat;
   amountOut: nat;
   amountOutFee: nat;
   err: opt Error__1;
   status: SwapStatus;
   tokenIn: Token__1;
   tokenOut: Token__1;
 };
type SwapArgs = 
 record {
   amountIn: text;
   amountOutMinimum: text;
   zeroForOne: bool;
 };
type Result_9 = 
 variant {
   err: Error;
   ok: record {
         balance0: nat;
         balance1: nat;
       };
 };
type Result_8 = 
 variant {
   err: Error;
   ok: UserWithdrawQueueInfo;
 };
type Result_7 = 
 variant {
   err: Error;
   ok:
    record {
      isProcessing: bool;
      items: vec WithdrawQueueItem;
      queueSize: nat;
    };
 };
type Result_6 = 
 variant {
   err: Error;
   ok: PoolMetadata;
 };
type Result_5 = 
 variant {
   err: Error;
   ok: record {
         tokensOwed0: nat;
         tokensOwed1: nat;
       };
 };
type Result_4 = 
 variant {
   err;
   ok: bool;
 };
type Result_33 = 
 variant {
   err: Error;
   ok: Page_5;
 };
type Result_32 = 
 variant {
   err: Error;
   ok:
    record {
      tokenIncome:
       vec record {
             nat;
             record {
               tokensOwed0: nat;
               tokensOwed1: nat;
             };
           };
      totalTokensOwed0: nat;
      totalTokensOwed1: nat;
    };
 };
type Result_31 = 
 variant {
   err: Error;
   ok: record {
         amount0: nat;
         amount1: nat;
       };
 };
type Result_30 = 
 variant {
   err: Error;
   ok: CycleInfo;
 };
type Result_3 = 
 variant {
   err: Error;
   ok: int;
 };
type Result_29 = 
 variant {
   err: Error;
   ok: record {
         feeGrowthGlobal0X128: nat;
         feeGrowthGlobal1X128: nat;
       };
 };
type Result_28 = 
 variant {
   err: Error;
   ok: PoolInitArgs;
 };
type Result_27 = 
 variant {
   err: Error;
   ok: vec record {
             LimitOrderType;
             LimitOrderKey;
             LimitOrderValue;
           };
 };
type Result_26 = 
 variant {
   err: Error;
   ok:
    record {
      lowerLimitOrders: vec record {
                              LimitOrderKey;
                              LimitOrderValue;
                            };
      upperLimitOrders: vec record {
                              LimitOrderKey;
                              LimitOrderValue;
                            };
    };
 };
type Result_25 = 
 variant {
   err: Error;
   ok: PositionInfo;
 };
type Result_24 = 
 variant {
   err: Error;
   ok: Page_4;
 };
type Result_23 = 
 variant {
   err: Error;
   ok:
    vec
     record {
       tickLimit: int;
       timestamp: nat;
       token0InAmount: nat;
       token1InAmount: nat;
       userPositionId: nat;
     };
 };
type Result_22 = 
 variant {
   err: Error;
   ok:
    record {
      errors: vec PushError;
      infoCid: text;
      records: vec SwapRecordInfo;
      retryCount: nat;
    };
 };
type Result_21 = 
 variant {
   err: Error;
   ok: vec record {
             int;
             nat;
           };
 };
type Result_20 = 
 variant {
   err: Error;
   ok: Page_3;
 };
type Result_2 = 
 variant {
   err: Error;
   ok: bool;
 };
type Result_19 = 
 variant {
   err: Error;
   ok: Page_2;
 };
type Result_18 = 
 variant {
   err: Error;
   ok:
    record {
      swapFee0Repurchase: nat;
      swapFee1Repurchase: nat;
      swapFeeReceiver: text;
      token0Amount: nat;
      token1Amount: nat;
    };
 };
type Result_17 = 
 variant {
   err: Error;
   ok: vec record {
             nat;
             Transaction;
           };
 };
type Result_16 = 
 variant {
   err: Error;
   ok:
    record {
      lowerLimitOrderIds: vec record {
                                timestamp: nat;
                                userPositionId: nat;
                              };
      upperLimitOrdersIds: vec record {
                                 timestamp: nat;
                                 userPositionId: nat;
                               };
    };
 };
type Result_15 = 
 variant {
   err: Error;
   ok: UserPositionInfo;
 };
type Result_14 = 
 variant {
   err: Error;
   ok: vec record {
             text;
             vec nat;
           };
 };
type Result_13 = 
 variant {
   err: Error;
   ok: vec nat;
 };
type Result_12 = 
 variant {
   err: Error;
   ok: Page_1;
 };
type Result_11 = 
 variant {
   err: Error;
   ok: Page;
 };
type Result_10 = 
 variant {
   err: Error;
   ok: vec UserPositionInfoWithId;
 };
type Result_1 = 
 variant {
   err: Error;
   ok: text;
 };
type Result = 
 variant {
   err: Error;
   ok: nat;
 };
type RemoveLimitOrderStatus = 
 variant {
   Completed;
   Created;
   Failed;
   LimitOrderDeleted;
 };
type RemoveLimitOrderInfo = 
 record {
   err: opt Error__1;
   positionId: nat;
   status: RemoveLimitOrderStatus;
   tickLimit: int;
   token0: Token__1;
   token0AmountIn: nat;
   token0AmountOut: nat;
   token1: Token__1;
   token1AmountIn: nat;
   token1AmountOut: nat;
 };
type RefundStatus = 
 variant {
   Completed;
   Created;
   CreditCompleted;
   Failed;
 };
type RefundInfo = 
 record {
   err: opt Error__1;
   relatedIndex: nat;
   status: RefundStatus;
   transfer: Transfer;
 };
type PushError = 
 record {
   message: text;
   time: int;
 };
type PositionInfoWithId = 
 record {
   feeGrowthInside0LastX128: nat;
   feeGrowthInside1LastX128: nat;
   id: text;
   liquidity: nat;
   tokensOwed0: nat;
   tokensOwed1: nat;
 };
type PositionInfo = 
 record {
   feeGrowthInside0LastX128: nat;
   feeGrowthInside1LastX128: nat;
   liquidity: nat;
   tokensOwed0: nat;
   tokensOwed1: nat;
 };
type PoolMetadata = 
 record {
   fee: nat;
   key: text;
   liquidity: nat;
   maxLiquidityPerTick: nat;
   nextPositionId: nat;
   sqrtPriceX96: nat;
   tick: int;
   token0: Token;
   token1: Token;
 };
type PoolInitArgs = 
 record {
   feeReceiverCid: principal;
   infoCid: principal;
   positionIndexCid: principal;
   token0: Token;
   token1: Token;
   trustedCanisterManagerCid: principal;
 };
type Page_5 = 
 record {
   content: vec record {
                  principal;
                  AccountBalance;
                };
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type Page_4 = 
 record {
   content: vec PositionInfoWithId;
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type Page_3 = 
 record {
   content: vec TickLiquidityInfo;
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type Page_2 = 
 record {
   content: vec TickInfoWithId;
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type Page_1 = 
 record {
   content: vec UserPositionInfoWithTokenAmount;
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type Page = 
 record {
   content: vec UserPositionInfoWithId;
   limit: nat;
   offset: nat;
   totalElements: nat;
 };
type OneStepSwapStatus = 
 variant {
   Completed;
   Created;
   DepositCreditCompleted;
   DepositTransferCompleted;
   Failed;
   PreSwapCompleted;
   SwapCompleted;
   WithdrawCreditCompleted;
 };
type OneStepSwapInfo = 
 record {
   deposit: DepositInfo;
   err: opt Error__1;
   status: OneStepSwapStatus;
   swap: SwapInfo;
   withdraw: WithdrawInfo;
 };
type MintArgs = 
 record {
   amount0Desired: text;
   amount1Desired: text;
   fee: nat;
   tickLower: int;
   tickUpper: int;
   token0: text;
   token1: text;
 };
type LimitOrderValue = 
 record {
   owner: principal;
   token0InAmount: nat;
   token1InAmount: nat;
   userPositionId: nat;
 };
type LimitOrderType = 
 variant {
   Lower;
   Upper;
 };
type LimitOrderKey = 
 record {
   tickLimit: int;
   timestamp: nat;
 };
type LimitOrderArgs = 
 record {
   positionId: nat;
   tickLimit: int;
 };
type Level = 
 variant {
   Active;
   Inactive;
 };
type JobInfo = 
 record {
   interval: nat;
   lastRun: Time;
   name: text;
   timerId: opt nat;
 };
type IncreaseLiquidityArgs = 
 record {
   amount0Desired: text;
   amount1Desired: text;
   positionId: nat;
 };
type Icrc28TrustedOriginsResponse = record {trusted_origins: vec text;};
type Icrc21ErrorInfo = record {description: text;};
type Icrc21Error = 
 variant {
   ConsentMessageUnavailable: Icrc21ErrorInfo;
   GenericError: record {
                   description: text;
                   error_code: nat;
                 };
   InsufficientPayment: Icrc21ErrorInfo;
   UnsupportedCanisterCall: Icrc21ErrorInfo;
 };
type Icrc21ConsentMessageSpec = 
 record {
   device_spec:
    opt
     variant {
       GenericDisplay;
       LineDisplay:
        record {
          characters_per_line: nat16;
          lines_per_page: nat16;
        };
     };
   metadata: Icrc21ConsentMessageMetadata;
 };
type Icrc21ConsentMessageResponse = 
 variant {
   Err: Icrc21Error;
   Ok: Icrc21ConsentInfo;
 };
type Icrc21ConsentMessageRequest = 
 record {
   arg: blob;
   method: text;
   user_preferences: Icrc21ConsentMessageSpec;
 };
type Icrc21ConsentMessageMetadata = 
 record {
   language: text;
   utc_offset_minutes: opt int16;
 };
type Icrc21ConsentMessage = 
 variant {
   GenericDisplayMessage: text;
   LineDisplayMessage: record {pages: vec record {lines: vec text;};};
 };
type Icrc21ConsentInfo = 
 record {
   consent_message: Icrc21ConsentMessage;
   metadata: Icrc21ConsentMessageMetadata;
 };
type GetPositionArgs = 
 record {
   tickLower: int;
   tickUpper: int;
 };
type ExecuteLimitOrderStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type ExecuteLimitOrderInfo = 
 record {
   err: opt Error__1;
   positionId: nat;
   status: ExecuteLimitOrderStatus;
   tickLimit: int;
   token0: Token__1;
   token0AmountIn: nat;
   token0AmountOut: nat;
   token1: Token__1;
   token1AmountIn: nat;
   token1AmountOut: nat;
 };
type Error__1 = text;
type Error = 
 variant {
   CommonError;
   InsufficientFunds;
   InternalError: text;
   UnsupportedToken: text;
 };
type DepositStatus = 
 variant {
   Completed;
   Created;
   Failed;
   TransferCompleted;
 };
type DepositInfo = 
 record {
   err: opt Error__1;
   status: DepositStatus;
   transfer: Transfer;
 };
type DepositArgs = 
 record {
   amount: nat;
   fee: nat;
   token: text;
 };
type DepositAndSwapArgs = 
 record {
   amountIn: text;
   amountOutMinimum: text;
   tokenInFee: nat;
   tokenOutFee: nat;
   zeroForOne: bool;
 };
type DepositAndMintArgs = 
 record {
   amount0: nat;
   amount0Desired: text;
   amount1: nat;
   amount1Desired: text;
   fee0: nat;
   fee1: nat;
   positionOwner: principal;
   tickLower: int;
   tickUpper: int;
 };
type DecreaseLiquidityStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type DecreaseLiquidityInfo = 
 record {
   amount0: nat;
   amount1: nat;
   err: opt Error__1;
   liquidity: nat;
   positionId: nat;
   status: DecreaseLiquidityStatus;
   token0: Token__1;
   token1: Token__1;
 };
type DecreaseLiquidityArgs = 
 record {
   liquidity: text;
   positionId: nat;
 };
type CycleInfo = 
 record {
   available: nat;
   balance: nat;
 };
type ClaimToSubaccountArgs = 
 record {
   positionId: nat;
   subaccount: blob;
 };
type ClaimStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type ClaimInfo = 
 record {
   amount0: nat;
   amount1: nat;
   err: opt Error__1;
   positionId: nat;
   status: ClaimStatus;
   token0: Token__1;
   token1: Token__1;
 };
type ClaimArgs = record {positionId: nat;};
type Amount = nat;
type AddLiquidityStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type AddLiquidityInfo = 
 record {
   amount0: nat;
   amount1: nat;
   err: opt Error__1;
   liquidity: nat;
   positionId: nat;
   status: AddLiquidityStatus;
   token0: Token__1;
   token1: Token__1;
 };
type AddLimitOrderStatus = 
 variant {
   Completed;
   Created;
   Failed;
 };
type AddLimitOrderInfo = 
 record {
   err: opt Error__1;
   positionId: nat;
   status: AddLimitOrderStatus;
   tickLimit: int;
   token0: Token__1;
   token0AmountIn: nat;
   token1: Token__1;
   token1AmountIn: nat;
 };
type Action = 
 variant {
   AddLimitOrder: AddLimitOrderInfo;
   AddLiquidity: AddLiquidityInfo;
   Claim: ClaimInfo;
   DecreaseLiquidity: DecreaseLiquidityInfo;
   Deposit: DepositInfo;
   ExecuteLimitOrder: ExecuteLimitOrderInfo;
   OneStepSwap: OneStepSwapInfo;
   Refund: RefundInfo;
   RemoveLimitOrder: RemoveLimitOrderInfo;
   Swap: SwapInfo;
   TransferPosition: TransferPositionInfo;
   Withdraw: WithdrawInfo;
 };
type AccountBalance = 
 record {
   balance0: nat;
   balance1: nat;
 };
type Account = 
 record {
   owner: principal;
   subaccount: opt blob;
 };
service : {
  activeJobs: () -> ();
  addLimitOrder: (LimitOrderArgs) -> (Result_2);
  allTokenBalance: (nat, nat) -> (Result_33) query;
  approvePosition: (principal, nat) -> (Result_2);
  batchRefreshIncome: (vec nat) -> (Result_32) query;
  checkOwnerOfUserPosition: (principal, nat) -> (Result_2) query;
  claim: (ClaimArgs) -> (Result_31);
  claimToSubaccount: (ClaimToSubaccountArgs) -> (Result_31);
  decreaseLiquidity: (DecreaseLiquidityArgs) -> (Result_31);
  deleteFailedTransaction: (nat, bool) -> (Result_2);
  deposit: (DepositArgs) -> (Result);
  depositAllAndMint: (DepositAndMintArgs) -> (Result);
  depositAndSwap: (DepositAndSwapArgs) -> (Result);
  depositFrom: (DepositArgs) -> (Result);
  depositFromAndSwap: (DepositAndSwapArgs) -> (Result);
  getAdmins: () -> (vec principal) query;
  getAvailabilityState: () ->
   (record {
      available: bool;
      whiteList: vec principal;
    }) query;
  getCachedTokenFee: () -> (record {
                              token0Fee: nat;
                              token1Fee: nat;
                            }) query;
  getClaimLog: () -> (vec text) query;
  getCycleInfo: () -> (Result_30);
  getFailedTransactions: () -> (Result_17) query;
  getFeeGrowthGlobal: () -> (Result_29) query;
  getInitArgs: () -> (Result_28) query;
  getJobs: () -> (record {
                    jobs: vec JobInfo;
                    level: Level;
                  }) query;
  getLimitOrderAvailabilityState: () -> (Result_2) query;
  getLimitOrderStack: () -> (Result_27) query;
  getLimitOrders: () -> (Result_26) query;
  getMistransferBalance: (Token) -> (Result);
  getPosition: (GetPositionArgs) -> (Result_25) query;
  getPositions: (nat, nat) -> (Result_24) query;
  getSortedUserLimitOrders: (principal) -> (Result_23) query;
  getSwapRecordState: () -> (Result_22) query;
  getTickBitmaps: () -> (Result_21) query;
  getTickInfos: (nat, nat) -> (Result_20) query;
  getTicks: (nat, nat) -> (Result_19) query;
  getTokenAmountState: () -> (Result_18) query;
  getTokenBalance: () -> (record {
                            token0: nat;
                            token1: nat;
                          });
  getTransactions: () -> (Result_17) query;
  getTransactionsByOwner: (principal) -> (Result_17) query;
  getUserByPositionId: (nat) -> (Result_1) query;
  getUserLimitOrders: (principal) -> (Result_16) query;
  getUserPosition: (nat) -> (Result_15) query;
  getUserPositionIds: () -> (Result_14) query;
  getUserPositionIdsByPrincipal: (principal) -> (Result_13) query;
  getUserPositionWithTokenAmount: (nat, nat) -> (Result_12) query;
  getUserPositions: (nat, nat) -> (Result_11) query;
  getUserPositionsByPrincipal: (principal) -> (Result_10) query;
  getUserUnusedBalance: (principal) -> (Result_9) query;
  getUserWithdrawQueue: () -> (Result_8) query;
  getVersion: () -> (text) query;
  getWithdrawQueueInfo: () -> (Result_7) query;
  icrc10_supported_standards: () ->
   (vec record {
          name: text;
          url: text;
        }) query;
  icrc21_canister_call_consent_message: (Icrc21ConsentMessageRequest) ->
   (Icrc21ConsentMessageResponse);
  icrc28_trusted_origins: () -> (Icrc28TrustedOriginsResponse);
  increaseLiquidity: (IncreaseLiquidityArgs) -> (Result);
  init: (nat, int, nat) -> ();
  metadata: () -> (Result_6) query;
  mint: (MintArgs) -> (Result);
  quote: (SwapArgs) -> (Result) query;
  quoteForAll: (SwapArgs) -> (Result) query;
  refreshIncome: (nat) -> (Result_5) query;
  removeLimitOrder: (nat) -> (Result_2);
  restartJobs: (vec text) -> ();
  restartWithdrawQueueProcessing: (bool) -> (Result_1);
  setAdmins: (vec principal) -> ();
  setAvailable: (bool) -> ();
  setIcrc28TrustedOrigins: (vec text) -> (Result_4);
  setLimitOrderAvailable: (bool) -> ();
  setWhiteList: (vec principal) -> ();
  stopJobs: (vec text) -> ();
  sumTick: () -> (Result_3) query;
  swap: (SwapArgs) -> (Result);
  transferPosition: (principal, principal, nat) -> (Result_2);
  updateTokenFee: () -> ();
  upgradeTokenStandard: (principal) -> (Result_1);
  withdraw: (WithdrawArgs) -> (Result);
  withdrawMistransferBalance: (Token) -> (Result);
  withdrawToSubaccount: (WithdrawToSubaccountArgs) -> (Result);
}
